{
  "meta": {
    "id": 213,
    "title": "打家劫舍 II",
    "difficulty": "中等",
    "leetcodeId": 213,
    "category": "dynamic_programming",
    "patterns": [
      "dynamic_programming_circular"
    ],
    "tags": [
      "数组",
      "动态规划"
    ],
    "estimatedTime": "25分钟",
    "passingRate": "50.0%",
    "version": "1.0",
    "lastUpdated": "2025-10-21"
  },
  "description": "你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。",
  "examples": [
    {
      "input": "nums = [2,3,2]",
      "output": "3",
      "explanation": "你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。"
    },
    {
      "input": "nums = [1,2,3,1]",
      "output": "4",
      "explanation": "你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4 。"
    },
    {
      "input": "nums = [1,2,3]",
      "output": "3",
      "explanation": "你可以偷窃 3 号房屋（金额 = 3）。"
    }
  ],
  "constraints": [
    "1 <= nums.length <= 100",
    "0 <= nums[i] <= 1000"
  ],
  "hints": [
    "这是一个环形问题，考虑两种情况",
    "情况1：偷第一间房，不偷最后一间房",
    "情况2：不偷第一间房，可以偷最后一间房"
  ],
  "followUp": "你能想出更优化的解法吗？考虑时间和空间复杂度。",
  "solutions": [
    {
      "id": "circular_dp",
      "name": "环形动态规划",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "description": "分两种情况处理环形数组",
      "code": {
        "javascript": "/**\n * 打家劫舍 II - 分两种情况处理环形数组\n */\n\nfunction rob(nums) {\n    const n = nums.length;\n    if (n === 1) return nums[0];\n    if (n === 2) return Math.max(nums[0], nums[1]);\n\n    function robLinear(start, end) {\n        let prev2 = 0, prev1 = 0;\n        for (let i = start; i <= end; i++) {\n            const current = Math.max(prev1, prev2 + nums[i]);\n            prev2 = prev1;\n            prev1 = current;\n        }\n        return prev1;\n    }\n\n    // 情况1：偷第一间房，不偷最后一间房 [0, n-2]\n    const case1 = robLinear(0, n - 2);\n    // 情况2：不偷第一间房，可以偷最后一间房 [1, n-1]\n    const case2 = robLinear(1, n - 1);\n\n    return Math.max(case1, case2);\n}\n\n\n/**\n * 测试rob函数\n */\nfunction testRob() {\n    console.log(\"=== rob测试 ===\");\n\n    // 测试用例\n    console.log(\"输入: nums = [2,3,2]\");\n    console.log(\"期望输出: 3\");\n    console.log(\"说明: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\");\n\n    console.log(\"\\n=== 测试完成 ===\");\n}\n\n// 如果需要运行测试，取消注释下面的行\n// testRob();",
        "python": "\"\"\"\n打家劫舍 II - 分两种情况处理环形数组\n\"\"\"\n\ndef rob(nums):\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return max(nums)\n\n    def rob_linear(start, end):\n        prev2 = prev1 = 0\n        for i in range(start, end + 1):\n            current = max(prev1, prev2 + nums[i])\n            prev2, prev1 = prev1, current\n        return prev1\n\n    # 情况1：偷第一间房，不偷最后一间房\n    case1 = rob_linear(0, n - 2)\n    # 情况2：不偷第一间房，可以偷最后一间房\n    case2 = rob_linear(1, n - 1)\n\n    return max(case1, case2)\n\n\ndef test_rob():\n    \"\"\"测试rob函数\"\"\"\n    print(\"=== rob测试 ===\")\n\n    # 测试用例\n    print(\"输入: nums = [2,3,2]\")\n    print(\"期望输出: 3\")\n    print(\"说明: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\")\n\n    print(\"\\n=== 测试完成 ===\")\n\n# 如果需要运行测试，取消注释下面的行\n# test_rob()"
      }
    }
  ],
  "aiExplanation": {
    "concept": {
      "title": "🧠 打家劫舍 II解题策略",
      "content": "这是一道经典的算法题目，重点学习解题思路和代码实现。"
    },
    "keyInsights": [
      "💰 理解题目的核心要求",
      "📊 选择合适的算法策略",
      "🔄 优化时间和空间复杂度"
    ],
    "commonMistakes": [
      "❌ 没有考虑边界条件",
      "❌ 算法实现有误",
      "❌ 忽略了题目的特殊要求"
    ]
  },
  "visualization": {
    "type": "step_by_step",
    "defaultData": {
      "input": "nums = [2,3,2]",
      "output": "3",
      "explanation": "你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。"
    },
    "steps": [
      {
        "step": 1,
        "description": "分析输入数据",
        "highlight": [],
        "action": "开始算法执行"
      }
    ]
  },
  "relatedProblems": [],
  "practiceExercises": [
    {
      "title": "打家劫舍 II变种练习",
      "description": "基于打家劫舍 II的变种问题",
      "difficulty": "中等",
      "hints": [
        "考虑边界情况",
        "优化算法复杂度"
      ]
    }
  ]
}